# ITMOScript

ITMOScript - динамически типизированный скриптовой язык c поддержкой чисел и арифметики, строк, списков и функций.

Пример программы на ITMOScript, вычисляющей факториал считанного из консоли числа:
```
// factorial.is
factorial = function(n)
    if n <= 1 then
        return 1
    end if
    return n * factorial(n - 1)
end function

n = parse_num(read())
while n == nil
    println("Not a number")
    n = parse_num(read())
end while

print(factorial(n))
```

## Основные правила
Код на ITMOScript представляет собой последовательность выражений и утверждений.

**Выражение** - это код, который можно вычислить, и который возвращает значение. Выражения состоят либо из примитивных частей (литералы и идентификаторы), либо из их комбинаций с помощью операторов.

**Утверждение** - код, который не возвращает значение, а служит, например, для контроля потока управления (к примеру, цикл).

Выражение не может быть перенесено на другую строку. Пробелы и табуляции могут быть добавлены в любом количестве и не влияют на выполнение программы. Код регистрозависим, так что "while" и "While" - это разные конструкции.

Комментарии начинаются с `//` и действуют до конца строки.

## Стандартные типы данных

Всего поддерживаются 7 стандартных типов данных. Тип данных определяет возможные операции над ним и между ним и другими типами.

### Int и Float
* *Int* (`3, -10`) - это 64-битные знаковые целые числа
* *Float* (`3.0, 9.1234, -0.22`) - числа с плавающей точкой с двойной точностью (double)
  * Поддерживается также научная нотация (`3e9, -1.23e-4`)

#### Операции
* Арифметические (`+, -, *, /, %, ^`)
* Сравнения (`<, <=, >, >=, ==, !=`)

При несовпадении числовых типов (например, при сложении *Int* и *Float*) *Int* приводится к *Float*.

### Bool
*Bool* - логический тип, `true`/`false`.

#### Операции
* Сравнение (`==, !=`)
* Арифметические операции с *Int* и *Float*
  * В этом случае *Bool* приводится к 1 или 0

### String
Тип *String* - динамическая строка. Литерал строки - последовательность символов в двойных кавычках (`"hello world"`).
Поддерживаются основные escape-последовательности: `\n, \t, \r, \', \", \?, \\, \a, \b, \f, \v`.

#### Операции
* Сравнения в лексикографическом порядке (`<, <=, >, >=, ==, !=`)
* Сложение (конкатенация): `"hello " + "world" == "hello world"`
* Вычитание суффикса: `"aaabbb" - "bbb" == "aaa"`
  * Если строка не оканчивается на строку из "вычитаемого", результат операции - левый операнд: `"aaabbb" - "ccc" == "aaabbb"`
* Умножение на число (запись строки n раз)
  * Умножение на отрицательное число вызовет RuntimeError.
  * Умножение на Float возвращает строку, записанную нецелое число раз: `"aaaa" * 1.5 == "aaaaaa"`
* Индексация: `"hello"[2] == "l"` (возвращает строку из 1 символа)
  * Присваивание по индексу запрещено, то есть запись `"hello"[0] = "f"` некорректна.
  * Отрицательные индексы отсчитываются с конца: `"hello"[-1] == "o"`
  * Выход за границы - RuntimeError.
* Слайс (копия части строки)
  * `s[:n]` - подстрока от первого до n символа (не включительно)
  * `s[n:]` - подстрока от n символа до конца
  * `s[m:n]` - подстрока от m-го символа до n-го (не включительно)
  * `s[:]` - копия всей строки
  * Отрицательные `m` или `n` - RuntimeError
  * Если `m:n`, `:n`, `m:` не являются корректными описаниями подстроки (выходят за границу, либо `m > n`), то возвращается пустая строка.

### List
Тип *List* - динамический массив. Позволяет хранить объекты любого типа, добавлять, удалять и менять элементы.
Литерал списка: `list = [1, 2, 3]`.

#### Операции
* Сравнения (`==, !=`)
* Сложение: `[1, 2] + [3, 4] == [1, 2, 3, 4]`
* Индексация и слайсы аналогично строке

Присвоение по индексу, вставка, удаление элементов доступны с помощью функций [стандартной библиотеки](#стандартная-библиотека).
При вставке значений в массив происходит копирование любых элементов, в отличие от [передачи в функцию](#функции).

### Function
Тип *Function* - функция, то есть функциональный объект. Позволяет вызывать себя с аргументами и выполнять тело. Подробнее про работу функций в разделе [функции](#функции).

Литерал типа *Function* имеет вид: `function(<args>) <body> end function`, например:
```
sqr = function(x)
    return x ^ 2
end function
```

#### Операции
* Сравнение (`==, !=`)
  * Две функции равны, только если это один и тот же объект. Содержание тела функции, количество аргументов и т. д. не имеет значения

Переменным, содержащим функцияи, нельзя присвоить другое значение после создания, то есть такой код вызовет RuntimeError:
```
x = function(n) return n + 1 end function
x = 1
```

### NullType
Особый тип *NullType* показывает отсутствие значения. Литерал: `nil`.

При присвоении и передаче в функцию примитивные типы (*Int*, *Float*, *Bool*, *NullType*) передаются по значению, остальные - по ссылке:

```
x = [1, 2, 3]
y = x
push(y, 4)
print(x) // [1, 2, 3, 4]
```

#### Операции
* Сравнение (`==, !=`)
  * NullType можно сравнивать со значениями любых типов. `==` вернёт `true`, только если тип обоих значений - NullType

## Операторы
Полный список операторов:

1. **Арифметические**
* `+`, `-`, `*`, `/`, `%` (остаток от деления)
* `^` (возведение в степень)
* Унарные `+` и `-`

2. **Сравнения**
* `==`, `!=`, `<`, `>`, `<=`, `>=`

3. **Логические**
* `and`, `or`, `not`

4. **Присваивания**
* `=`, `+=`, `-=`, `*=`, `/=`, `%=`, `^=`

5. **Другие**
* `[]` (индексация)

## Условные выражения
Синтаксис:

```
if условие then
    // consequence
elseif условие then
    // consequence
else
    // consequence
end if
```
Это именно **выражение** то есть данный оператор возвращает значение в зависимости от условия. Если ни одно условие не выполнено, возвращает *NullType*.

Благодаря этому можно писать так: `rem = if y % 2 == 0 then 1 else 0 end if`.

## Циклы

### while
Синтаксис:

```
while условие
    // body
end while
```
Тут ничего нового, работает как и везде.

### for
Синтаксис:

```
for i in array
    // body
end for
```

Здесь `i` "пробегает" всю последовательность `array`, принимая каждое значение из неё.
Важно: `i` - копия элемента из `array`, а не ссылка на него. Область видимости `i` ограничена телом цикла.

Более классический вариант:
```
for i in range(n)
    // body
end for
```
См. функцию `range()` из [стандартной библиотеки](#стандартная-библиотека).

### Break & Continue
Ключевые слова `break` и `continue` имеют привычный смысл при использование в циклах

## Функции
Функции в ITMOScript являются [объектом первого класса](https://en.wikipedia.org/wiki/First-class_function), и имеют отдельный тип данных. В отличии от, например, С++, функции в ITMOScript объявляются через переменную. Для определения функции используется ключевое слово `function`. Количество аргументов не ограничивается. В качестве аргументов могут приниматься любые стандартные типы данных, включая сами функции.

Синтаксис:
```
name = function(<args>)
   // body
   return result
end function
```

Вызов функций осуществляется так же, как и в большинстве языков:

```
function_name(<comma-separated arguments>)
calculate(x, y, z, 100, -1)
```

Так как функции в ITMOScript являются обычным объектом, их можно [передавать как аргументы и возвращать](https://en.wikipedia.org/wiki/Higher-order_function). Синтаксис аналогичен другим типам данных:

```
ilovefunctions("pass existing function...", func)

ilovefunctions("...or define one inplace", function(args)
    // do smth
end function)

alias = anotherfunc
```

Функции также могут определять другие функции внутри себя, однако внутренние функции не захватывают переменные из родительской функции. Это означает, что "родительская" область видимости внутри **любой** функции - глобальная. Отсюда следует, что рекурсивно вызвать можно только функцию, созданную в глобальной области видимости.

Примитивные типы (*Int*, *Float*, *Bool*) передаются по значению, остальные - по ссылке. Таким образом, например, можно изменять переданный массив.

## Область видимости
Объекты, созданные в глобальной области области видимости, доступны из любой области видимости.

Локальная область видимости создаётся при входе в блок:
* Тело цикла
* Последствие if-выражения
* Тело функции

При присвоении к переменной сперва проверяется, зарегистрирована ли она в текущей области видимости. Если нет, то проверяется в родительских (внешних) областях видимости вплоть до глобавльной.
Если переменная зарегистрирована во внешней области видимости, она меняется там, иначе создаётся в локальной.

Попытка обращения к переменной, не зарегистрированной ни в одной из доступных на данный момент областей видимости - RuntimeError.

При входе в функцию создаётся локальная область видимости, в которой устанавливается значение параметров функции, и при обращении к ним поиска во внешней области не происходит. То есть происходит так называемое *затеменение* внешних переменных.

## Стандартная библиотека
ITMOScript предоставляет базовые функции для работы с числами, строками, списками, файлами и вводом/выводом. В отличие от пользовательских функций, стандартные функции осуществляют явную проверку типов аргументов, и несответствие типов вызовет RuntimeError.

### Числа
* `abs(x)` - абсолютное значение, возвращает *Int*/*Float*
* `ceil(x)` - округление вверх, возвращает *Int*
* `floor(x)` - округление вниз, возвращает *Int*
* `round(x)` - округление до ближайшего целого, возвращает *Int*
* `sqrt(x)` - квадратный корень, возвращает *Float*
* `rnd(n)` - случайное целое от `0` до `n - 1`, возвращает *Int*
* `parse_num(s)` - преобразует строку в число если возможно, иначе `nil`, возвращает *Int*/*NulLType*
* `to_string(n)` - преобразует число в строку, возвращает *String*

### Строки
* `len(s)` - длина строки, возвращает *Int*
* `lower(s)` - в нижний регистр, возвращает *String*
* `upper(s)` - в верхний регистр, возвращает *String*
* `split(s, delim)` - разделение строки, возвращает *List*
* `join(list, delim)` - объединение списка в строку, возвращает *String*
* `replace(s, old, new)` - замена подстроки. Меняет исходную строку, возвращает NullType.

### Списки
* `range(x, y, step)` - возвращает список чисел `[x; y)` с шагом `step`
  * `range(x)` возвращает список чисел `[0; x)` с шагом `1`.
  * `range(x, y)` возвращает список чисел `[x; y)` с шагом `1`.
  * При отрицательном шаге обязательно `x >= y`.
  * `step == 0` вызовет RuntimeError
  * Поведение аналогично `range()` в Python, только возвращается сразу список чисел.
* `len(list)` - длина списка, возвращает *Int*
* `push(list, x)` - добавить элемент в конец, возвращает *List*
* `pop(list)` - удалить и вернуть последний элемент, возвращает элемент
* `insert(list, index, x)` - вставить элемент, возвращает *List*
* `remove(list, index)` - удалить элемент, возвращает *List*
* `set(list, index, x)` - установить значение элемента по индексу, возвращает *List*
* Обращение по некорректному индексу в `insert(), remove(), set()` приведёт к RuntimeError.
* `sort(list)` - сортировка, возвращает *List*

Для сортировки используются следующие правила сравнения.

В случае, если 2 объекта имеют разные типы, то они сравниваются по приоритету типов, а именно:
1. Int
2. Float
3. Bool
4. String
5. List
6. Function
7. NullType

\* Для Int и Float применяются правила сравнения объектов одного типа:

Два объекта одного типа сравниваются по правилам:
* Любые два NullType равны
* Для Int и Float сравниваются числа
* Строки сравниваются лексикографически
* false < true
* Функции несравнимы, так что их порядок неопределён. Не сортируйте функции
* Списки сравниваются поэлементно ("лексикографически")
* NullType "меньше" любого не-NullType значения

### Системные функции

* `print(x)` - вывод в поток вывода без дополнительных символов и перевода строки, возвращает *NullType*
* `println(x)` - вывод в поток вывода с последующим переводом строки, возвращает *NullType*
* `read()` - читает и возвращает строку из потока ввода, возвращает *String*
* `type_of(x)` - возвращает строку с названием типа переменной `x`, возвращает *String*
* `stacktrace()` - возвращает текущий стек вызова функций.
  * Формат стека: список из 2-х элементных списков. Первый элемент каждого такого списка - имя вызванной функции, второй элемент - строка, на которой функция была вызвана.

### Работа с файлами

* `file_read(name)` - чтение всего файла, возвращает *String*
* `file_read_lines(name)` - чтение всего файла с разделением на строки, возвращает *List*, содержащий *String*
* `file_write(name, content)` - запись строки в файл с перезаписью, возвращает *NullType*
* `file_append(name, content)` - запись строки в файл с добавлением в конец, возвращает *NullType*
* `file_exists(name)` - проверяет, существует ли файл с указанным именем, возвращает *Bool*

## Примечания
Это учебный проект, написанный в рамках курса по программированию на C++ в ИТМО на 1 курсе.
Я не планирую его развивать, однако буду благодарен за найденные баги и советы по улучшению существующего решения.
